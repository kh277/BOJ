# 백준 12147

'''
주의 반례
4
4 7 7
4 7 6
4 7 2
2 8 2

->
10
10
14
10

'''
import sys

input = sys.stdin.readline


def solve(case, R, C, W):
    score = 0

    '''
    1번 과정의 경우 solve(R, C, W)와 같다.
    1행 ~ R-1행까지는 전부 배가 없다고 대답할 것이다.
    따라서 배가 절반을 넘지 않을 경우, C-(W-1)*2번 확인하면 그 행에 배의 존재 여부를 확인할 수 있다.
    배의 길이가 절반을 넘을 경우, 한 행당 1번만 확인하면 된다.
    '''
    # 행이 2개 이상일 경우
    if R > 1:
        score += (R-1) * (C//W)
    # 행이 1개뿐일 경우
    else:
        pass

    '''
    2번 과정의 경우 solve(1, C, W)와 같다.
    마지막 행에는 배가 반드시 존재하게 된다.
    C=10에 W=3라고 가정해보면, 가능한 배의 위치는 10칸이다.
    0123456789에서 2을 부르면 틀렸다고 할 것이다. 이 때, 가능한 배의 위치는 7칸 중 2칸이다.
    다시 5를 부르면 틀렸다고 할 것이고, 이 때, 가능한 배의 위치는 4칸 중 2칸이다.
    따라서, 가능한 배의 위치가 W ~ 2W-1이 되기 전까지는 다 틀렸다고 할 것이다.
    '''
    
    left = 0
    # 배의 길이가 절반을 넘는다면
    if W*2 > C:
        left = C
        pass
    # 배의 길이가 절반을 넘지 않는다면
    else:
        temp = (C-W) // W
        score += temp
        left = C - temp*W

    '''
    3번 과정의 경우 solve(1, C-temp*W, W)가 된다.
    이제 W ~ 2W-1 칸에서 배의 위치를 확인하면 된다.
    남은 칸은 C - temp * W이다.
    다시 위 예시에서 생각해보면 남은 칸은 0123456789 중 0123만 남게 된다.
    이 중에서 배가 확실하게 있는 위치는 1, 2이다.
    배의 확실한 위치는 W*2 - (남은 칸)개만큼 존재하게 된다.
    그 뒤에는 012이거나 123 중 하나이므로 처음 대답한 것은 무조건 틀렸다고 할 것이다. 여기서 +1회가 추가된다.
    그 다음에 남은 칸만큼 전부 확인해주면 된다.
    '''
    score += W*2 - left

    # 배가 남은 칸을 꽉 채울 경우
    if W == left:
        pass
    # 배가 남은 칸을 꽉 채우지 않을 경우
    else:
        score += 1
        score += left - W

    return 'Case #{0}: {1}'.format(case, score)


def main():
    T = int(input())
    for case in range(1, T+1):
        R, C, W = map(int, input().split())

        print(solve(case, R, C, W))


main()
